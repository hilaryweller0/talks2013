\subsection{Practical: Solving the Shallow-water Equations}

Code to solve the linearised shallow-water equations:
\begin{align*}
\frac{\partial u}{\partial t} &= fv - g\frac{\partial}{\partial x}(h+h_0)\\
\frac{\partial v}{\partial t} &= -fu - g\frac{\partial}{\partial y}(h+h_0)\\
\frac{\partial h}{\partial t} & + 
\frac{\partial}{\partial x}\bigl((H-h_0)u\bigr) + \frac{\partial}{\partial y}\bigl((H-h_0)v\bigr)
 = 0
\end{align*}
using the Arakawa A and C-grids are in file \url{pythonExamples/SWE/*.py}. $u$ and $v$ are the velocities in directions $x$ and $y$, $f=\beta y$ is the Coriolis parameter, $g$ is gravity, $h$ is the depth anomaly in comparison to the mean depth $H$ and $h_0$ is the height of the bottom topography. The boundary conditions in the $x$ direction are periodic and the the $y$ direction the boundary conditions are $v=0$ and $\partial h/\partial y=0$. In the code in \url{pythonExamples/SWE/*.py}, the bottom topography has not been fully implemented. The code is set up to solve a test case with a geostrophically balanced jet described by:
\begin{eqnarray*}
u(\hat{y}) & = & \begin{cases}
u_m\left(1-3\hat{y}^{2}+3\hat{y}^{4}-\hat{y}^{6}\right) & \text{for }-1\le\hat{y}\le1\\
0 & \text{otherwise}
\end{cases}\\
v & = & 0\\
\end{eqnarray*}
\begin{eqnarray*}
h\left(\hat{y}\right) & = & \begin{cases}
16\ w\beta u_m y_{c}/(35g) & \textnormal{for }\hat{y}\le-1\\
-w\beta u_m/g\begin{array}[t]{l}
\bigl\{ y_{c}\left(\hat{y}-\hat{y}^{3}+3\hat{y}^{5}/5-\hat{y}^{7}/7\right)\\
+w\left(-1/8+\hat{y}^{2}/2-3\hat{y}^{4}/4+\hat{y}^{6}/2-\hat{y}^{8}/8\right)\bigr\}
\end{array} & \textnormal{for }-1\le\hat{y}\le1\\
-16\ w\beta u_m y_{c}/(35g) & \textnormal{for }\hat{y}\ge1
\end{cases}
\end{eqnarray*}
where $\hat{y}=(y-y_{c})/w$, $y_{c}$ is the $y$ position
of the jet centre, $w$ is the jet half width, $u_m$ is the maximum
jet velocity and $h_{0}$ is the minimum height.

\begin{enumerate}
\item Run the A- and C-grid versions of the shallow-water code. The errors for this case can easily be calculated by comparing the initial and final conditions since the initial conditions are the analytic solution. Calculate and plot the errors after running for 1 day. 
%With reference to your answer to question 3 of the first practical (on numerical differentiation), explain 
Why the C-grid results are more accurate than the A-grid results?
\item Add a mountain defined by:
\begin{equation*}
h_0 = \begin{cases}
h_{0\max}(1-\sqrt{(x-x_c)^2 + (y-y_c)^2}/r_m) &
\text{ for } \sqrt{(x-x_c)^2 + (y-y_c)^2} < r_m\\
0 & \text{ otherwise}
\end{cases}
\end{equation*}
where $(x_c,y_c)$ is the mountain centre which is in the middle of the domain, $r_m=5\times10^5\text{m}$ is the mountain radius and $h_{0\max}=500\text{m}$ is the mountain peak height. You will need to add the definition of the mountain to function \url{createMountain} in file \url{pythonExamples/SWE/initialAndPlot.py} and include the influence of the orography in the correct terms of the SWE in functions \url{SWE_Cgrid} and \url{SWE_Agrid} in file \url{pythonExamples/SWE/ACgrids.py}. Plot the results for both schemes after 10 days. Can you explain the problems with the A-grid results?

\clearpage
{\bf Additional things to try}

\item Run for longer. Does the wave generated by the mountain become clearer? What else do you notice about the results.

\item Make the mountain one grid-box wide.

\item Make the jet faster. Can you initiate any barotropic instability?

\item Implement a B-grid.

\end{enumerate}


\clearpage
\subsection{Lessons from the practical}
\clearpage

